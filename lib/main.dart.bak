import 'package:flutter/material.dart';

void main() {
  runApp(const PillCityAPP());
}

class PillCityAPP extends StatelessWidget {
  const PillCityAPP({Key? key}) : super(key: key);

  // 此部件是應用程式的根。
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        // 這是應用程序的主題。
        // 嘗試使用“flutter run”來執行應用程式。您將看到應用程式有一個藍色工具列。然後，在不退出應用程式的情況下，嘗試將下麵的primarySwatch更改為Colors.green，然後呼叫“hot reload”（在執行“flutter run”的控制檯中按“r”，或將更改儲存到Flutter IDE中的“hot reload”）。請注意，計數器沒有重置回零；應用程式未重新啟動。
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({Key? key, required this.title}) : super(key: key);

  // 此小部件是應用程式的主頁。它是有狀態的，這意味著它有一個狀態物件（定義如下），其中包含影響其外觀的欄位。
  // 此類是狀態的配置。它儲存由父級（本例中為應用程式小部件）提供並由狀態的構建方法使用的值（本例中為標題）。小部件子類中的欄位始終標記為“final”。

  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      // 對 setState 的呼叫告訴 Flutter 框架在此狀態下發生了更改，這導致它重新執行下面的構建方法，以便顯示可以反映更新的值。如果我們在不呼叫 setState() 的情況下更改了_計數器，那麼構建方法將不會再次被呼叫，因此似乎不會發生任何事情。
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    // 每次呼叫setState時都會重新執行此方法，例如，上面的_incrementCounter方法。
    // Flutter 框架已經過最佳化，可以快速地重新執行構建方法，因此您可以只重建任何需要更新的內容，而不必單獨更改小部件的例項。
    return Scaffold(
      appBar: AppBar(
        // 這裡，我們從App.build方法建立的MyHomePage物件中獲取值，並使用它設定appbar標題。
        title: Text(widget.title),
      ),
      body: Center(
        // 中心是一個佈局小部件。它需要一個孩子，把它放在父母的中間。
        child: Column(
          // 列也是一個佈局小部件。它獲取子物件列表並垂直排列它們。預設情況下，它調整自身大小以水平適應其子物件，並嘗試與其父物件一樣高。
          // 呼叫 debug painting (在控制檯中按 p , 從 Android Studio 中的 Flutter 檢查器中選擇 Toggle Debug Paint 操作，或在 Visual Studio Code 中選擇 Toggle Debug Paint 命令) 以檢視每個小部件的線框。
          // 列具有各種屬性來控制其自身大小和子項位置。在這裡，我們使用mainAxisAlignment使子物件垂直居中；這裡的主軸是垂直軸，因為柱是垂直的（橫軸是水平的）。
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            const Text(
              'You have pushed the button this many times:',
            ),
            Text(
              '$_counter',
              style: Theme.of(context).textTheme.headline4,
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ), // 此尾隨逗號使生成方法的自動格式設定更方便。
    );
  }
}
